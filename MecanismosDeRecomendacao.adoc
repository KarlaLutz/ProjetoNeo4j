= Mecanismos de Recomendações
:neo4j-version: 2.0.0-RC1


*Sumário*

* *Introdução*
** <<introdução-ao-problema, Introdução ao Problema>>
* *Cenário*
** <<descrevendo-o-cenário, Descrevendo o Cenário>>
* *Solução*
** <<detalhamento-da-solução, Detalhamento da Solução>>
** <<como-bancos-de-dados-em-grafos-podem-ser-eficientes, Como Bancos de Dados em Grafos podem ser Eficientes>>
* *Modelo de Dados*
** <<modelo-do-banco-de-dados-de-mecanismos-de-recomendação, Modelo do Banco de Dados de Mecanismos de Recomendação>>
* *Configuração do Banco de Dados*
** <<exemplo-do-banco-de-dados, Exemplo do Banco de Dados>>
* *Cypher Queries*
** <<entity_link_analysis, Entity Link Analysis>>
** <<find_account_holders_who_share_more_than_one_piece_of_legitimate_contact_information, Find account holders who share more than one piece of legitimate contact information>>
** <<determine_the_financial_risk_of_a_possible_fraud_ring , Determine the financial risk of a possible fraud ring>>

'''

== Introdução ao Problema

É de conhecimentos comum que um banco de dados é uma parte essencial de qualquer aplicação. Por isso a decisão de qual banco de dados utilizar para a sua aplicação é muito crucial. Você deve levar em consideração diversos fatores, muitas vezes as empresas optam por bancos de dados relacionais, os quais não são uma escolha ruim, porém dependendo da quantidade de dados a serem armazenados e se a aplicação depende de uma performance alta, talvez a melhora escolha seja um banco de dados NoSQL.

Existem diversos tipos de bancos de dados NoSQL, porém quando precisamos tratar especificamente de conexão entre dados que geralmente são problemas que empresas tentam resolver com um banco de dados relacional comum, podemos dizer com toda certeza que um banco de dados baseado em Grafos é a melhor maneira de suportar um cenário onde temos um grande volume de dados e de variedades de estruturas de dados sem contar a alta escalabilidade e velocidade. 

Tendo em mente toda essa capacidade do banco de dados, será tratado neste documento um caso de uso de uma agência de marketing que precisa melhorar o seu mecanismo de recomendação de produto para seus clientes ecommerces, melhorando o desempenho operacional e ajudando na diminuição de gastos com campanhas de marketing que não possuem um ROI positivo.


'''

== Descrevendo o Cenário

É difícil encontrar uma empresa online que não utilize algum tipo de mecanismo de recomendação para atingir seus cliente com produtos ou serviços relevantes. Um bom mecanismo de recomendação deve correlacionar muitos dados e ser capaz de detectar rapidamente novos interesses, rapidamente compreendê-los, buscar na web e recomendar de volta para os usuários.

Caso esse mecanismo não seja acertivo pode-se perde investimentos feitos na campanha de marketing por não ter um retorno, onde caso você esteja recomendando produtos para os usuários onde eles não possuem nenhum interesse, será apenas gerado um spam e essa campanha será ignorada. É exatamente o caso da agência de marketing XYZ, um dos produtos que a agência fornece à seus clientes é o E-mail Retargeting. Esse produto funciona com um mecanismo de recomendação que entende através de cookies a navegação do usuário nos websites dos ecommerces (clientes da agência) e dispara um e-mail pós navegação do usuário, com produtos que podem ser de interesse dele baseado no comportamento dele dentro do site.

A intenção é que esses produtos sejam produtos relacionados com as categorias pesquisadas e produtos visualizados, porém o mecanismo de e-mail retargeting da agência XYZ está falhando no sentido em que as relações dentro do atual banco de dados relacional não estão atualizando com a velocidade necessária e estão perdendo indexes. Como consequência dessa falha de arquitetura, os clientes estão sendo impactados por e-mails com produtos já comprados e estão entrando com vários chamados de reclamação de spam para os ecommerces.

Os ecommerces clientes da XYZ estão desistindo do produto devido a essa falha, alegando que o produto não está trazendo o mínimo de ROI esperado e que na realidade está gerando mais problemas para eles.


'''

== Detalhamento da Solução

Sendo focado em entidades e as relações entre eles, um banco de dados em Grafo pode lidar facilmente com recomendações. Por ter esse foco, não importa a quantidade de nós dentro do data base, a capacidade de armazenamento e processamento será sempre a mesma, superando significativamente outros bancos de dados relacionais e não relacionais.

Para a agência XYZ esse modelo de banco de dados irá substâncialmente resolver o cenário negativo com os clientes pois o problema de indexes incorretos deixará de existir uma vez que o banco de dados em Grafo não possui e essa estrutura e também esse banco tem uma alta escalabilidade da quantidade de dados armazenados como mencionado anteriormente e velocidade de atualização.


=== Como Bancos de Dados em Grafos podem ser Eficientes

Augmenting one’s existing fraud detection infrastructure to support ring detection can be done by running appropriate entity link analysis queries using a graph database, and running checks during key stages in the customer & account lifecycle, such as:

* At the time the account is created
* During an investigation
* As soon as a credit balance threshold is hit
* When a check is bounced

Real-time graph traversals tied to the right kinds of events can help banks identify probable fraud rings: during or even before the Bust-Out occurs.

'''

== Modelo do Banco de Dados de Mecanismos de Recomendação

Graph databases have emerged as an ideal tool for overcoming these hurdles. Languages like Cypher provide a simple semantic for detecting rings in the graph, navigating connections in memory, in real time. 

The graph data model below represents how the data actually looks to the graph database, and illustrates how one can find rings by simply walking the graph:

image::https://raw.github.com/neo4j-contrib/gists/master/other/images/BankFraud-1.png[Bank Fraud]

'''

== Exemplo do Banco de Dados

//setup
[source,cypher]
----

// Create account holders
CREATE (accountHolder1:AccountHolder { 
       		FirstName: "John", 
       		LastName: "Doe", 
       		UniqueId: "JohnDoe" }) 

CREATE (accountHolder2:AccountHolder { 
			FirstName: "Jane", 
			LastName: "Appleseed", 
			UniqueId: "JaneAppleseed" }) 

CREATE (accountHolder3:AccountHolder { 
			FirstName: "Matt", 
			LastName: "Smith", 
			UniqueId: "MattSmith" }) 

// Create Address
CREATE (address1:Address { 
			Street: "123 NW 1st Street", 
			City: "San Francisco", 
			State: "California", 
			ZipCode: "94101" })

// Connect 3 account holders to 1 address
CREATE (accountHolder1)-[:HAS_ADDRESS]->(address1), 
       (accountHolder2)-[:HAS_ADDRESS]->(address1), 
       (accountHolder3)-[:HAS_ADDRESS]->(address1)

// Create Phone Number
CREATE (phoneNumber1:PhoneNumber { PhoneNumber: "555-555-5555" })

// Connect 2 account holders to 1 phone number
CREATE (accountHolder1)-[:HAS_PHONENUMBER]->(phoneNumber1), 
       (accountHolder2)-[:HAS_PHONENUMBER]->(phoneNumber1)

// Create SSN
CREATE (ssn1:SSN { SSN: "241-23-1234" })

// Connect 2 account holders to 1 SSN
CREATE (accountHolder2)-[:HAS_SSN]->(ssn1), 
       (accountHolder3)-[:HAS_SSN]->(ssn1)

// Create SSN and connect 1 account holder
CREATE (ssn2:SSN { SSN: "241-23-4567" })<-[:HAS_SSN]-(accountHolder1)

// Create Credit Card and connect 1 account holder
CREATE (creditCard1:CreditCard { 
			AccountNumber: "1234567890123456", 
			Limit: 5000, Balance: 1442.23, 
			ExpirationDate: "01-20", 
			SecurityCode: "123" })<-[:HAS_CREDITCARD]-(accountHolder1)

// Create Bank Account and connect 1 account holder
CREATE (bankAccount1:BankAccount { 
			AccountNumber: "2345678901234567", 
			Balance: 7054.43 })<-[:HAS_BANKACCOUNT]-(accountHolder1)

// Create Credit Card and connect 1 account holder
CREATE (creditCard2:CreditCard { 
			AccountNumber: "1234567890123456", 
			Limit: 4000, Balance: 2345.56, 
			ExpirationDate: "02-20", 
			SecurityCode: "456" })<-[:HAS_CREDITCARD]-(accountHolder2)

// Create Bank Account and connect 1 account holder
CREATE (bankAccount2:BankAccount { 
			AccountNumber: "3456789012345678", 
			Balance: 4231.12 })<-[:HAS_BANKACCOUNT]-(accountHolder2)

// Create Unsecured Loan and connect 1 account holder
CREATE (unsecuredLoan2:UnsecuredLoan { 
			AccountNumber: "4567890123456789-0", 
			Balance: 9045.53, 
			APR: .0541, 
			LoanAmount: 12000.00 })<-[:HAS_UNSECUREDLOAN]-(accountHolder2)

// Create Bank Account and connect 1 account holder
CREATE (bankAccount3:BankAccount { 
			AccountNumber: "4567890123456789", 
			Balance: 12345.45 })<-[:HAS_BANKACCOUNT]-(accountHolder3)

// Create Unsecured Loan and connect 1 account holder
CREATE (unsecuredLoan3:UnsecuredLoan { 
			AccountNumber: "5678901234567890-0", 
			Balance: 16341.95, APR: .0341, 
			LoanAmount: 22000.00 })<-[:HAS_UNSECUREDLOAN]-(accountHolder3)

// Create Phone Number and connect 1 account holder
CREATE (phoneNumber2:PhoneNumber { 
			PhoneNumber: "555-555-1234" })<-[:HAS_PHONENUMBER]-(accountHolder3)

RETURN *
----

//graph

'''

== Entity Link Analysis

Performing entity link analysis on the above data model is demonstrated below.

==== Find account holders who share more than one piece of legitimate contact information

[source,cypher]
----
MATCH 		(accountHolder:AccountHolder)-[]->(contactInformation) 
WITH 		contactInformation, 
			count(accountHolder) AS RingSize 
MATCH 		(contactInformation)<-[]-(accountHolder) 
WITH 		collect(accountHolder.UniqueId) AS AccountHolders, 
			contactInformation, RingSize
WHERE 		RingSize > 1 
RETURN 		AccountHolders AS FraudRing, 
			labels(contactInformation) AS ContactType, 
			RingSize
ORDER BY 	RingSize DESC
----

//output
//table

==== Determine the financial risk of a possible fraud ring

[source,cypher]
----
MATCH 		(accountHolder:AccountHolder)-[]->(contactInformation) 
WITH 		contactInformation, 
			count(accountHolder) AS RingSize 
MATCH 		(contactInformation)<-[]-(accountHolder), 
			(accountHolder)-[r:HAS_CREDITCARD|HAS_UNSECUREDLOAN]->(unsecuredAccount)
WITH 		collect(DISTINCT accountHolder.UniqueId) AS AccountHolders, 
			contactInformation, RingSize,
			SUM(CASE type(r)
				WHEN 'HAS_CREDITCARD' THEN unsecuredAccount.Limit
				WHEN 'HAS_UNSECUREDLOAN' THEN unsecuredAccount.Balance
				ELSE 0
			END) as FinancialRisk
WHERE 		RingSize > 1
RETURN 		AccountHolders AS FraudRing, 
			labels(contactInformation) AS ContactType, 
			RingSize, 
			round(FinancialRisk) as FinancialRisk
ORDER BY 	FinancialRisk DESC
----

//output
//table
